# -*- coding: utf-8 -*-
"""Main Representation_preparation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tA7xwOm5D8L5eTIwYZigvRcND9dAQqS2

# **Representation preparation**

This document will explore the preparation of the database EmpatheticConversations for the Empathy classification task. It was necessary to prepare and separate the different features on the database in order for the data to be processed by the Waikato Environment for Knowledge Analysis (WEKA).
"""

#Pandas and numpy imports
import pandas as pd
import numpy as np

#Read the database
df = pd.read_excel('EmpatheticConversations.xlsx')
df

"""The data in EmpatheticConversations presents some attributes as a single string. Therefore, it is necessary to separate it."""

df['Sentiment'][0]

"""### **Sentiment analysis**"""

#Sentiment analysis separation

def sentiment_separator(s,n):
  s2 = s[s.find(":")+1+s.find('{'):s.find("}")]
  s3 = s2[s2.find('{')+1:]
  array = s3.split(", ")
  return float(array[n][array[n].find(':')+1:])


df['Negative_score'] = df['Sentiment'].apply(sentiment_separator,args = (0,))
df['Neutral_score'] = df['Sentiment'].apply(sentiment_separator,args = (1,))
df['Positivity_score'] = df['Sentiment'].apply(sentiment_separator,args = (2,))

df = df.drop(columns=['Sentiment'])
df

"""## **Emotion analysis**"""

#Emotion analysis separation
#Order: 'Happy','Fear','Sad','Bored','Angry','Excited'

def emotion_separator(s):
  emotions = ['Happy','Fear','Sad','Bored','Angry','Excited']
  em_arr = [0,0,0,0,0,0]
  s = s[s.find(': {')+3:s.find('}}')]
  array = s.split(", ")

  for x in array:
    for y in range(len(emotions)):
      if emotions[y] in x:
        em_arr[y] = float(x[x.find(':')+1:])
  return em_arr

df['Emotions'] = df['Emotion'].apply(emotion_separator)

def emo_arr_sep(s,n):
  return s[n]

emo_names = ['Happy','Fear','Sad','Bored','Angry','Excited']

for x in range(len(emo_names)):
  df[emo_names[x]] = 0

for x in range(len(emo_names)):
  df[emo_names[x]] = df['Emotions'].apply(emo_arr_sep,args=(x,))

df = df.drop(columns=['Emotions','Emotion'])

df

"""## **Obtain different Taxonomical features**"""

#Obtain Taxonomical features
def obtain_tax(s):
  #s = df['Taxonomy'][0]
  s = s[s.find("[")+1:]
  #s = s.split('}, {')
  s = s.split(',')
  s
  for x in s:
    if 'tag' not in s:
      s.remove(x)
  for i in range(len(s)):
    s[i] = s[i][s[i].find(': ')+3:s[i].find("}")-1]
  return s

df['Tax_array'] = df['Taxonomy'].apply(obtain_tax)

#Obtain Taxonomical scores

def obtain_tax_sc(s):
#s = df['Taxonomy'][0]
  s = s[s.find("[")+1:]
  s = s[s.find("{")+1:s.find("}]}")]
  s = s.split('}, {')
  for i in range(len(s)):
    arr = s[i].split(',')
    #print(arr)
    new_arr = [arr[1][arr[1].find(": '")+3:len(arr[1])-1],float(arr[0][arr[0].find(': ')+1:])]
    #print(new_arr)
    s[i] = new_arr
  return s
#s = s.split(',')

df['Tax_values'] = df['Taxonomy'].apply(obtain_tax_sc)
#df6
df

"""## Obtain intent scores"""

#Obtaining intent values

intents = ['news','query','spam','marketing','feedback','complaint','suggestion','appreciation']

def get_intent(s):
  s = s[s.find("':")+4:]
  arr = s.split(',')
  arr
  if len(arr) > 5:
    #print(arr[4][:arr[4].find('{')])
    #print(arr[4][arr[4].find("re':")+4:])
    s = ''+ arr[4][:arr[4].find('{')]+ arr[4][arr[4].find("re':")+4:]
    arr[4] = s

    k = arr[5]
    k = k[k.find(': {')+3:]

    arr[5] = k

    t = arr[7]
    t = t[:t.find("}}")]
    #print(t)
    arr[7] = t
  else:
    arr[4] = arr[4][:arr[4].find("}}")]
    arr.append("'complaint': 0.0")
    arr.append("'suggestion': 0.0")
    arr.append("'appreciation': 0.0")

  for i in range(len(arr)):
    arr[i] = arr[i].replace("'", "")
    arr[i] = arr[i].replace(" ", "")
    val = arr[i].split(':')
    arr[i] = [val[0],float(val[1])]
  return arr

df['Intent_values'] = df['Intent'].apply(get_intent)
df = df.drop(columns=['Taxonomy','Intent'])


def intent_separation(s,i):
  return s[i][1]

for i in range(len(intents)):
  df[intents[i]] = df['Intent_values'].apply(intent_separation, args= (i,))

df = df.drop(columns=['Intent_values'])


df

#Obtain taxonomical variables as values

tax_array = []


for i in range(len(df['Tax_array'])):
  for y in df['Tax_array'][i]:
    tax_array.append(y)
#tax_array


def unique(list1):
    # intilize a null list
    unique_list = []
    # traverse for all elements
    for x in list1:
        # check if exists in unique_list or not
        if x not in unique_list:
            unique_list.append(x)
    # print list
    return unique_list

unique_tax_array = unique(tax_array)

print(len(tax_array))
print(len(unique_tax_array))
#unique_tax_array


def find_tax(s,cat):
  for x in s:
    if x[0] == unique_tax_array[cat]:
      return x[1]
  return 0

for i in range(len(unique_tax_array)):
  df[unique_tax_array[i]] = df['Tax_values'].apply(find_tax,args=(i,))


df

#Creation of "Talker" feature: 1 Speaker, 2 Listener
df = df.drop(columns=['prompt','Tax_array','Tax_values'])

def q1_q2(s):
  if s%2 == 0:
    return 2
  else:
    return 1

df['Talker'] = df['utterance_idx'].apply(q1_q2)
df.drop(columns=['conv_id','utterance','speaker_idx'])
df

#Encoding context values into a categorical variable

"""
Equivalence:

1 : afraid
2 : angry
3 : annoyed
4 : anticipatinc
5 : anxious
6 : apprehensive
7 : ashamed
8 : caring
9 : confident
10 : content
11 : devastated
12 : disappointed
13 : disgusted
14 : embarassed
15 : excited
16 : faithful
17 : furious
18 : grateful
19 : guilty
20 : hopeful
21 : impressed
22 : jealous
23 : joyful
24 : lonely
25 : nostalgic
26 : prepared
27 : proud
28 : sad
29 : sentimental
30 : surprised
31 : terrified
32 : trusting
"""


df["context"] = df["context"].astype('category')

df["context_encoded"] = df["context"].cat.codes

df["context_encoded"] = df["context_encoded"].astype('category')


df = df.drop(columns=['context'])
df = df.drop(columns=['conv_id','utterance','speaker_idx'])

"""# Plutchik representation

In our work, we explored the viability of transforming the context from a single encoded value into a Plutchik vectorial value. For this, we change the encoded context categorical variable into various vectorial variables corresponding to Plutchik's emotion model.

"

#Transforming context to Plutchik representation


plutchik_equivalencies = [[[0,0,1,0,0,0,0,0],2], #afraid
 [[0,0,0,0,0,0,1,0],2], #angry
 [[0,0,0,0,0,0,1,0],3], #annoyed
 [[0,0,0,0,0,0,0,1],2], #anticipating
 [[0,0,1,0,0,0,0,0],2], #anxious
 [[0,0,1,0,0,0,0,0],3], #apprehensive
 [[0,0,1,0,0,1,0,0],2], #ashamed
 [[1,1,0,0,0,0,0,0],2], #caring
 [[1,0,0,0,0,0,0,1],2], #confident
 [[1,0,0,0,0,0,0,0],3], #content
 [[0,0,0,1,1,1,0,0],1], #devastated
 [[0,0,0,1,1,0,0,0],2], #disappointed
 [[0,0,0,0,0,1,0,0],2], #disgusted
 [[0,0,1,0,0,1,0,0],3], #embarassed
 [[1,0,0,0,0,0,0,1],3], #excited
 [[1,1,0,1,0,0,0,0],1], #faithful
 [[0,0,0,0,0,0,1,0],1], #furious
 [[1,1,0,1,0,0,0,0],2], #grateful
 [[1,0,1,0,0,0,0,0],2], #guilty
 [[0,1,0,0,0,0,0,1],2], #hopeful
 [[0,1,0,1,0,0,0,0],1], #impressed
 [[0,0,0,0,1,0,1,0],2], #jealous
 [[1,0,0,0,0,0,0,0],2], #joyful
 [[0,0,0,0,1,0,0,0],1], #lonely
 [[1,0,0,0,1,0,0,0],2], #nostalgic
 [[0,0,0,0,0,0,0,1],2], #prepared
 [[1,0,0,0,0,0,1,0],2], #proud
 [[0,0,0,0,1,0,0,0],2], #sad
 [[0,1,0,0,0,0,0,0],2], #sentimental
 [[0,0,0,1,0,0,0,0],2], #surprised
 [[0,0,1,0,0,0,0,0],1], #terrified
 [[0,1,0,0,0,0,0,0],2]] #trusting


def plut_arr_separator(s,n):
  return plutchik_equivalencies[s][0][n]

def plut_intesity_separator(s):
  return plutchik_equivalencies[s][1]

emotion_categories = ["joy", "trust", "fear", "surprise", "sadness", "disgust", "anger", "anticipation"]


for x in range(len(emotion_categories)):
  df12['PL '+emotion_categories[x]] = 0

df12['PL intensity'] = 0

for x in range(len(emotion_categories)):
  df12['PL '+emotion_categories[x]] = df12['context_encoded'].apply(plut_arr_separator,args=(x,))
  df12['PL '+emotion_categories[x]] = df12['PL '+emotion_categories[x]].astype('string')

df12['PL intensity'] = df12['context_encoded'].apply(plut_intesity_separator)
#df12['PL intensity'] = df12['PL intensity'].astype('string')

df12 = df12.drop(columns=['context','context_encoded'])

#End of Plutchik

# Sending of prepared_csv

We finally output the processed csv that will be used to carry out the classification task
"""

df.rename(columns = {'ARTS & CULTURE':'ARTS&CULTURE'}, inplace = True)
df.rename(columns = {'HEALTHY LIVING':'HEALTHYLIVING'}, inplace = True)
df

df.to_csv('Empathyabase.csv', index = False)