# -*- coding: utf-8 -*-
"""Full database PBC4cip training.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vokl_zI-ofzfyoHGaBPEiHnzpTvTlLHm

# Training of PBC4cip

In this document, we train and save a version of PBC4cip using the entire database. The databse presents the following format:

*   Empathyabase.csv

The result from this code will be a saved version of PBC4cip that can be used in other code, the output will be:

1.   A .sav file with the format: trained_pbc4cip.sav


### WARNING: The PBC4cip python implementation takes a long time to run. Around an hour per fold. It is much more maneagable to carry out the classification process using this specific classifier in WEKA
"""

pip install pbc4cip

#Importing of libraries necessary for classification and manipulation of database

from PBC4cip import PBC4cip
import os
import argparse
import numpy as np
import pandas as pd

from tqdm import tqdm, trange
from PBC4cip import PBC4cip
from PBC4cip.core.Evaluation import obtainAUCMulticlass
from PBC4cip.core.Helpers import get_col_dist, get_idx_val


#Import pickle to save the model
import pickle

"""## Creation of classifiers"""

#Creation of classifier
pbc = PBC4cip(tree_count = 100) # 100 tree cound og


#Generation of classification array
classifiers = [pbc]
class_names = ['PBC4CIP']

"""## Classification"""

#Values for each classifier are stored in the array
acc_list = []
recall_list = []
precision_list = []
auc_list = []
confusion_list = []

#Scoring function for PBC4CIP
def score(predicted, y):
        y_class_dist = get_col_dist(y[f'{y.columns[0]}'])
        real = list(map(lambda instance: get_idx_val(y_class_dist, instance), y[f'{y.columns[0]}']))
        numClasses = len(y_class_dist)
        confusion = [[0]* numClasses for i in range(numClasses)]
        classified_as = 0
        error_count = 0

        for i in range(len(real)):
            if real[i] != predicted[i]:
                error_count = error_count + 1
            confusion[real[i]][predicted[i]] = confusion[real[i]][predicted[i]] + 1

        acc = 100.0 * (len(real) - error_count) / len(real)
        auc = obtainAUCMulticlass(confusion, numClasses)

        return confusion, acc, auc


for cls in classifiers:

  #Training the classifier

  data_tra = pd.read_csv('Empathyabase.csv')

  #Preparation
  # We ensure that the variables are taken as categories and not integers or floats

  data_tra['Empathy'] = data_tra['Empathy'].astype('string')
  data_tra["utterance_idx"] = data_tra["utterance_idx"].astype('category')
  data_tra["Talker"] = data_tra["Talker"].astype('category')
  data_tra["context_encoded"] = data_tra["context_encoded"].astype('category')

  #Separate target values for training

  X1_train = data_tra.drop(columns=['Empathy'])
  Y1_train = data_tra.drop(columns=X1_train.columns)
  #PBC4CIP
  patterns = cls.fit(X1_train, Y1_train)

"""# Save model"""

import pickle

# save the model to disk
filename = 'trained_pbc4cip.sav'
pickle.dump(pbc, open(filename, 'wb'))